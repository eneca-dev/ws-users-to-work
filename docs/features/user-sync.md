# Синхронизация пользователей Worksection → eneca.work

## Цель

Создать отдельное приложение для односторонней синхронизации пользователей из Worksection в Supabase (eneca.work). Приложение должно автоматически синхронизировать данные пользователей, отслеживать изменения, обрабатывать удаленных пользователей (перемещение в отдел "удаленные") и предоставлять детальные отчеты.

## Синхронизируемые поля

- `email` — email пользователя
- `first_name` — имя
- `last_name` — фамилия
- `department` — отдел
- `group` — команда (team)
- `role` — роль (owner, admin, user, guest, reader)
- `rate` — ставка (если указана)

## Особенности

1. **Дедупликация**: идемпотентность через `(external_id, external_source)`
2. **Валидация**: проверка корректности всех данных из Worksection перед записью
3. **Обработка удаленных**: пользователи отсутствующие в WS → перемещаются в отдел "удаленные"
4. **Отчет об изменениях**: детальная информация что, где и почему изменилось
5. **Архитектура**: аналогична ws-to-work (модульность, файлы <300 строк)

## Критерии готовности (Definition of Done)

- [ ] Все пользователи из Worksection синхронизируются в Supabase
- [ ] Синхронизируются все обязательные поля: email, first_name, last_name, rate, role, department, group
- [ ] Идемпотентность: повторный запуск не создает дублей
- [ ] Обновление существующих пользователей при изменении данных
- [ ] Content hash для определения изменений
- [ ] Обработка удаленных пользователей (перемещение в отдел "удаленные")
- [ ] Детальный отчет: что изменилось, добавилось, удалилось
- [ ] Telegram уведомления с CSV отчетом о синхронизации
- [ ] Веб-интерфейс для ручного запуска синхронизации
- [ ] REST API эндпоинты для интеграции
- [ ] Логирование всех операций
- [ ] Обработка ошибок без остановки всего процесса

---

## Этапы реализации

### Этап 1: Инициализация проекта и конфигурация

**Описание:**
Создание базовой структуры Node.js проекта, установка зависимостей, настройка конфигурации.

**Затрагиваемые файлы:**
- `package.json` — зависимости и скрипты (новый)
- `.env.example` — шаблон переменных окружения (новый)
- `.gitignore` — игнорируемые файлы (новый)
- `config/env.js` — загрузка и валидация переменных (новый)
- `CLAUDE.md` — инструкции для Claude Code (новый)
- `README.md` — документация проекта (новый)

**Зависимости:**
- Нет (первый этап)

**Результат:**
- Рабочая структура проекта
- Настроенные переменные окружения
- Установленные зависимости (Express, Supabase, Axios, Crypto-js и т.д.)

---

### Этап 2: Worksection API клиент

**Описание:**
Создание сервиса для работы с Worksection API v2, включая аутентификацию через MD5 хеш и метод получения пользователей.

**Затрагиваемые файлы:**
- `services/worksection.js` — API клиент (новый)
- `utils/logger.js` — система логирования (новый)

**Зависимости:**
- Этап 1 (конфигурация)

**Ключевые функции:**
- `generateHash(queryParams)` — генерация MD5 хеша
- `request(action, params)` — базовый запрос к API
- `getUsers()` — получение всех пользователей
- Обработка ошибок API

**Результат:**
- Работающий клиент для Worksection API
- Получение списка пользователей с полями: id, first_name, last_name, email, department, group, role, rate

---

### Этап 3: Supabase клиент и работа с profiles

**Описание:**
Создание сервиса для работы с Supabase, включая CRUD операции для таблицы profiles и идемпотентные upsert методы.

**Затрагиваемые файлы:**
- `services/supabase.js` — Supabase клиент (новый)
- `utils/validator.js` — валидация и нормализация данных (новый)

**Зависимости:**
- Этап 1 (конфигурация)

**Ключевые функции:**
- `getUsers()` — получить всех пользователей
- `getUserByKey(externalSource, externalId)` — поиск по внешнему ключу
- `createUser(data)` — создать пользователя
- `updateUser(id, data)` — обновить пользователя
- `upsertUserByKey(externalSource, externalId, data)` — идемпотентный upsert
- `moveUserToDepartment(userId, departmentName)` — переместить в отдел
- `getDepartmentByName(name)` — получить отдел по имени
- `countUsers()` — подсчет пользователей

**Результат:**
- CRUD операции для profiles
- Идемпотентная синхронизация через external_id + external_source
- Content hash для определения изменений

---

### Этап 4: Валидация и нормализация данных

**Описание:**
Создание системы валидации данных пользователей из Worksection, нормализации полей и расчета content hash.

**Затрагиваемые файлы:**
- `utils/validator.js` — валидация (расширение)

**Зависимости:**
- Этап 3 (Supabase клиент)

**Ключевые функции:**
- `validateUser(data)` — валидация всех полей пользователя
- `sanitizeString(str, maxLength)` — очистка строк
- `validateEmail(email)` — проверка формата email
- `calculateContentHash(user)` — MD5 хеш для определения изменений
- `needsUpdate(existingHash, newHash)` — проверка необходимости обновления
- `validateDeduplicationKey(externalId, externalSource)` — проверка ключей

**Правила валидации:**
- Email: обязателен, валидный формат
- First/Last name: обязательны, max 255 символов
- Department/Group: опционально, max 255 символов
- Role: один из допустимых значений
- Rate: число >= 0 (если указана)

**Результат:**
- Гарантия корректности данных перед записью
- Предотвращение некорректных данных в БД
- Content hash для отслеживания изменений

---

### Этап 5: Логика синхронизации пользователей

**Описание:**
Основная логика синхронизации: получение пользователей из обоих источников, сравнение, создание/обновление, обработка удаленных.

**Затрагиваемые файлы:**
- `sync/user-sync.js` — логика синхронизации (новый)
- `sync/sync-manager.js` — координатор синхронизации (новый)

**Зависимости:**
- Этап 2 (Worksection API)
- Этап 3 (Supabase клиент)
- Этап 4 (Валидация)

**Алгоритм синхронизации:**

```
1. Получить пользователей из Worksection (wsUsers)
2. Получить пользователей из Supabase (supaUsers)
3. Для каждого wsUser:
   a. Валидировать данные
   b. Найти существующего по external_id
   c. Если существует:
      - Вычислить content_hash
      - Если изменился → UPDATE (логировать что изменилось)
      - Если не изменился → SKIP
   d. Если не существует:
      - CREATE (логировать создание)
4. Для пользователей в Supabase НО отсутствующих в WS:
   a. Переместить в отдел "удаленные"
   b. Логировать перемещение
5. Собрать статистику: created, updated, unchanged, moved_to_deleted, errors
```

**Отслеживание изменений:**
- Сравнение content_hash ДО и ПОСЛЕ
- Детальный лог: какое поле изменилось (old → new)
- Формат: `email changed: old@example.com → new@example.com`

**Результат:**
- Полная синхронизация пользователей
- Обработка всех edge-cases
- Детальная статистика операций

---

### Этап 6: Статистика и отчеты

**Описание:**
Система сбора детальной статистики синхронизации, отслеживания изменений полей, формирования отчетов.

**Затрагиваемые файлы:**
- `sync/sync-manager.js` — расширение для статистики

**Зависимости:**
- Этап 5 (Логика синхронизации)

**Структура статистики:**
```javascript
{
  users: {
    created: 0,
    updated: 0,
    unchanged: 0,
    moved_to_deleted: 0,
    errors: 0
  },
  field_changes: {
    email: 0,
    first_name: 0,
    last_name: 0,
    department: 0,
    group: 0,
    role: 0,
    rate: 0
  },
  detailed_report: {
    actions: [
      {
        action: 'created' | 'updated' | 'moved_to_deleted' | 'error',
        user_id: '123',
        email: 'user@example.com',
        timestamp: '...',
        changes: [
          { field: 'rate', old: 100, new: 150 }
        ]
      }
    ]
  },
  count_before: { total: 100, synced: 95 },
  count_after: { total: 103, synced: 98 },
  delta: { added: 3, deleted: 0 }
}
```

**Результат:**
- Полная прозрачность процесса синхронизации
- Возможность аудита изменений
- Детальные отчеты для анализа

---

### Этап 7: Express сервер и API эндпоинты

**Описание:**
Создание Express сервера с REST API для запуска синхронизации, получения логов и статуса.

**Затрагиваемые файлы:**
- `app.js` — Express сервер (новый)
- `public/index.html` — веб-интерфейс (новый)

**Зависимости:**
- Этап 5 (Логика синхронизации)
- Этап 6 (Статистика)

**API эндпоинты:**
- `POST /api/sync` — запуск синхронизации
- `GET /api/logs` — получение логов
- `POST /api/logs/clear` — очистка логов
- `GET /api/health` — проверка статуса
- `GET /` — веб-интерфейс

**Результат:**
- HTTP API для интеграции
- Веб-интерфейс для ручного управления

---

### Этап 8: Telegram уведомления

**Описание:**
Интеграция с Telegram Bot API для отправки уведомлений о начале/завершении синхронизации и CSV отчетов.

**Затрагиваемые файлы:**
- `services/telegram.js` — Telegram клиент (новый)
- `services/telegram-bot.js` — обработчик команд бота (новый)

**Зависимости:**
- Этап 6 (Статистика)
- Этап 7 (Express сервер)

**Функции:**
- `sendSyncStarted(countBefore)` — уведомление о начале
- `sendCsvFile(logs, stats, startTime, endTime)` — отправка CSV отчета
- `sendError(error, context)` — уведомление об ошибке
- `handleUpdate(update)` — обработка команд бота

**Команды бота:**
- `/start_sync` — запустить синхронизацию
- `/help` — справка
- `/start` — приветствие

**CSV формат отчета:**
```
SYNC SUMMARY
Started, Finished, Duration

STATISTICS
Created: X, Updated: Y, Moved to deleted: Z

FIELD CHANGES
Rate changes: 5
Department changes: 3

DELTA (Added by Sync)
Before: 100 users, After: 103 users
Added: 3 users

DETAILED LOGS
[timestamp] [level] message
```

**Результат:**
- Автоматические уведомления в Telegram
- CSV отчеты для анализа
- Управление через бота

---

### Этап 9: Обработка отдела "удаленные"

**Описание:**
Специальная логика для обработки пользователей, отсутствующих в Worksection — перемещение в отдел "удаленные" вместо удаления.

**Затрагиваемые файлы:**
- `sync/user-sync.js` — расширение логики
- `services/supabase.js` — добавление методов для работы с отделами

**Зависимости:**
- Этап 5 (Логика синхронизации)

**Алгоритм:**
```
1. После синхронизации активных пользователей
2. Найти пользователей в Supabase с external_source='worksection'
   НО отсутствующих в текущем списке из WS
3. Для каждого такого пользователя:
   a. Проверить текущий отдел
   b. Если не в "удаленные":
      - Сохранить старый отдел в метаданные
      - Переместить в отдел "удаленные"
      - Логировать: "User X moved from Department Y to 'удаленные'"
```

**Дополнительные методы:**
- `findDeletedDepartment()` — найти/создать отдел "удаленные"
- `getUsersNotInWorksection(wsUserIds)` — найти пользователей для перемещения
- `moveUserToDepartment(userId, departmentId, oldDepartment)` — переместить с метаданными

**Результат:**
- Пользователи не удаляются физически
- История перемещений сохраняется
- Возможность восстановления

---

### Этап 10: Финальная интеграция и документация

**Описание:**
Финальная интеграция всех компонентов, обновление документации, создание примеров использования.

**Затрагиваемые файлы:**
- `README.md` — полная документация (обновление)
- `SETUP.md` — инструкции по установке (новый)
- `CLAUDE.md` — инструкции для Claude (обновление)
- `.env.example` — обновление примера конфигурации

**Зависимости:**
- Все предыдущие этапы

**Документация включает:**
- Описание проекта
- Инструкции по установке и настройке
- Примеры использования API
- Описание структуры проекта
- Troubleshooting
- Примеры конфигурации для разных окружений

**Результат:**
- Полностью задокументированный проект
- Готовность к деплою
- Удобство для других разработчиков

---

## Технологический стек

- **Runtime**: Node.js 18+
- **Framework**: Express.js
- **Database**: Supabase (PostgreSQL)
- **External API**: Worksection API v2
- **Notifications**: Telegram Bot API
- **Hashing**: crypto-js (MD5)
- **HTTP Client**: axios
- **Environment**: dotenv

## Архитектурные принципы

1. **Модульность**: каждый файл <300 строк
2. **Разделение ответственности**: services → sync → app
3. **Идемпотентность**: повторный запуск безопасен
4. **Graceful degradation**: ошибки не останавливают весь процесс
5. **Подробное логирование**: прозрачность всех операций
6. **Типизация данных**: валидация на входе и выходе

## Безопасность

- Переменные окружения для секретов
- Валидация всех входных данных
- Защита API эндпоинтов (опционально: auth middleware)
- Логирование без чувствительных данных
- Content hash для проверки целостности

## Производительность

- Batch операции где возможно
- Пагинация для больших объемов
- Кеширование (future: Redis)
- Минимальное количество запросов к БД

## Тестирование (manual)

### Позитивные сценарии
- [ ] Синхронизация нового пользователя из WS → создание в Supabase
- [ ] Обновление существующего пользователя → изменение полей
- [ ] Без изменений → skip (unchanged)
- [ ] Запуск синхронизации через веб-интерфейс
- [ ] Запуск через Telegram бота
- [ ] Получение CSV отчета

### Негативные сценарии
- [ ] Некорректный email → ошибка валидации, пропуск пользователя
- [ ] Отсутствие обязательных полей → ошибка, логирование
- [ ] Сетевая ошибка WS API → повторная попытка, fallback
- [ ] Ошибка Supabase → логирование, продолжение с другими

### Edge cases
- [ ] Пользователь удален из WS → перемещение в "удаленные"
- [ ] Изменение только rate → обновление, логирование
- [ ] Duplicate email в WS → обработка конфликта
- [ ] Большое количество пользователей (100+) → пагинация

## Метрики успеха

- ✅ 100% пользователей синхронизируются без потерь
- ✅ <1% ошибок при валидации данных
- ✅ Все изменения отслеживаются в детальном отчете
- ✅ Время синхронизации <10 секунд для 100 пользователей
- ✅ Telegram уведомления доставляются в течение 5 секунд

---

## Следующие шаги после завершения

1. Автоматическая синхронизация по расписанию (cron)
2. Dashboard для визуализации статистики
3. История изменений пользователей (audit log)
4. Webhooks для интеграции с другими системами
5. Unit тесты (Jest)
